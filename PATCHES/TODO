TODO
================================================================================

getboottime()
	- needs  G_ and V_ variant and applied correctly in the right places.
	- failed/xdr
	- xhr,  sys/sys/time.h

hostid?

failed/xej	sysv_msg ...
failed/xek	sysv_sem ...
failed/xel	sysy_shm ...
	}}} all three need proper OSD save/restore if we keep it?

xes -> vfs_cache.c needs review;  just applied blindly so far.
	- compiles now :)

Lots of &prison0 vs. V_prison0  (no &)  but only in some places;  check that!
	- the osd calls take the prison0 argument twice; check those still


vps_pager_getpages()

------------------------------------------
vpsctl shell testvps triggers:

root@rabbit3:~ # panic: Bad tailq NEXT(0xffffffff819f6260->tqh_last) != NULL
cpuid = 0
time = 1500552184
KDB: stack backtrace:
db_trace_self_wrapper() at db_trace_self_wrapper+0x2b/frame 0xfffffe085f8976b0
vpanic() at vpanic+0x19c/frame 0xfffffe085f897730
panic() at panic+0x43/frame 0xfffffe085f897790
tty_makedevf() at tty_makedevf+0x4cf/frame 0xfffffe085f8978e0
pts_alloc2() at pts_alloc2+0x215/frame 0xfffffe085f897940
sys_posix_openpt_unit() at sys_posix_openpt_unit+0x61/frame 0xfffffe085f897980
amd64_syscall() at amd64_syscall+0x859/frame 0xfffffe085f897ab0
Xfast_syscall() at Xfast_syscall+0x104/frame 0xfffffe085f897ab0
--- syscall (504, FreeBSD ELF64, sys_posix_openpt), rip = 0x800881e1a, rsp = 0x7fffffffe188, rbp = 0x7fffffffe1c0 ---
KDB: enter: panic
[ thread pid 882 tid 100124 ]
Stopped at      kdb_enter+0x3b: movq    $0,kdb_why
db> show all ttys
PTR                      LINE   INQ  CAN  LIN  LOW  OUTQ  USE  LOW   COL  SESS  PGID STATE
0xfffff8000798cc00      ttyu0     0    0    0    0     0    0    0     0     0     0 IC
0xfffff8000798c800      ttyu1 23040    0    0 2304 23064    0 2307    17   826   876 ICOi
0xfffff8000b800c00      ttyv0  1920    0    0  192  1984    0  199     7   818   818 Oil
0xfffff8000b800800      ttyv1  1920    0    0  192  1984    0  199     7   819   819 Oil
0xfffff8000b800400      ttyv2  1920    0    0  192  1984    0  199     7   820   820 Oil
0xfffff8000b800000      ttyv3  1920    0    0  192  1984    0  199     7   821   821 Oil
0xfffff8000b7ffc00      ttyv4  1920    0    0  192  1984    0  199     7   822   822 Oil
0xfffff8000b7ff800      ttyv5  1920    0    0  192  1984    0  199     7   823   823 Oil
0xfffff8000b7ff400      ttyv6  1920    0    0  192  1984    0  199     7   824   824 Oil
0xfffff8000b7ff000      ttyv7  1920    0    0  192  1984    0  199     7   825   825 Oil
0xfffff8000b7fec00      ttyv8     0    0    0    0     0    0    0     0     0     0 -
0xfffff8000b7fe800      ttyv9     0    0    0    0     0    0    0     0     0     0 -
0xfffff8000b7fe400      ttyva     0    0    0    0     0    0    0     0     0     0 -
0xfffff8000b7fe000      ttyvb     0    0    0    0     0    0    0     0     0     0 -
0xfffff8000bf27000      pts/0  1920    0    0  192  1984    0  199     0   840   882 Oi
0xfffff8000a0c4400    console     0    0    0    0     0    0    0     0     0     0 s
0xfffff8000a0c4400    console     0    0    0    0     0    0    0     0     0     0 s
0xfffff8000a0c4400    console     0    0    0    0     0    0    0     0     0     0 s
0xfffff8000a0c4400    console     0    0    0    0     0    0    0     0     0     0 s

(gdb) l *pts_alloc2+0x215
0xffffffff80ae4c75 is in pts_alloc2 (/tank/users/bz/vps_zambcom/vps_zabcom/sys/kern/tty_pts.c:822).
817             knlist_init_mtx(&psc->pts_outpoll.si_note, tp->t_mtx);
818
819             /* Expose the slave device as well. */
820             tty_makedev(tp, td->td_ucred, "pts/%u", psc->pts_unit);
821
822             finit(fp, fflags, DTYPE_PTS, tp, &ptsdev_ops);
823
824             return (0);
825     }
826

(gdb) l *tty_makedevf+0x4cf
0xffffffff80adeb4f is at /tank/users/bz/vps_zambcom/vps_zabcom/sys/kern/tty.c:1387.
1382                            dev_depends(dev, clock);
1383                    }
1384            }
1385
1386            sx_xlock(&tty_list_sx);
1387            TAILQ_INSERT_TAIL(&tty_list, tp, t_list);
1388            tty_list_count++;
1389            sx_xunlock(&tty_list_sx);
1390
1391            return (0);

The corruption most likely happens as vps1 is created, not when it's accessed.
Tracking this (possibly memory corruption and not queue-misue by manually
mangling things) will be interesting.

tracing caught it early:

vps initialized.
vps0: bpf attached
tty_makedevf:1396 count 15 check ...
tty_makedevf:1399 count 16 check ...
tty_makedevf:1396 count 16 check ...
tty_makedevf:1399 count 17 check ...
panic: Bad tailq NEXT(0xffffffff819f6260->tqh_last) != NULL
cpuid = 0
time = 1500561872
KDB: stack backtrace:
db_trace_self_wrapper() at db_trace_self_wrapper+0x2b/frame 0xfffffe085f80e270
vpanic() at vpanic+0x19c/frame 0xfffffe085f80e2f0
panic() at panic+0x43/frame 0xfffffe085f80e350
tty_makedevf() at tty_makedevf+0x529/frame 0xfffffe085f80e4a0
vps_console_alloc() at vps_console_alloc+0x155/frame 0xfffffe085f80e500
vps_alloc() at vps_alloc+0x970/frame 0xfffffe085f80e660
vps_ioc_create() at vps_ioc_create+0x95/frame 0xfffffe085f80e690
devfs_ioctl() at devfs_ioctl+0xc0/frame 0xfffffe085f80e6e0
VOP_IOCTL_APV() at VOP_IOCTL_APV+0xe0/frame 0xfffffe085f80e710
vn_ioctl() at vn_ioctl+0x124/frame 0xfffffe085f80e820
devfs_ioctl_f() at devfs_ioctl_f+0x1f/frame 0xfffffe085f80e840
kern_ioctl() at kern_ioctl+0x2cd/frame 0xfffffe085f80e8a0
sys_ioctl() at sys_ioctl+0x16f/frame 0xfffffe085f80e980
amd64_syscall() at amd64_syscall+0x859/frame 0xfffffe085f80eab0
Xfast_syscall() at Xfast_syscall+0x104/frame 0xfffffe085f80eab0
--- syscall (54, FreeBSD ELF64, sys_ioctl), rip = 0x8009ba6da, rsp = 0x7fffffffc8d8, rbp = 0x7fffffffeaa0 ---
KDB: enter: panic
[ thread pid 843 tid 100099 ]
Stopped at      kdb_enter+0x3b: movq    $0,kdb_why

What actually happens is that pts_alloc() calls tty_makedev() and that adds the
tp to the end of the tailq;  vps_console_alloc() then saves the dev, and calls
tty_makedev() again to create the console with the correct cred before deleting
the old dev.  However it passes the same tp to tty_makedev() which means the same
tp will be added to the end of the queue again.  During that process the next
pointer will be updated on the original entry, which now is the same as the last
one, hence the last one also has a valid next pointer pointing to itself;
assertion fires.  It is unclear how this has ever worked in 10.0 as the code
is exactly the same.

------------------------------------------





# end
